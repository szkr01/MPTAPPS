<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SSD 摩耗平滑化＆冗長性 可視化ツール</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" integrity="sha512-DTOQO9RWCH3ppGqcWaEA1BIZOC6xxalwEsw9c2QQeAIftl+Vegovlnee1c9QX4TctnWMn13TZye+giMm8e2LwA==" crossorigin="anonymous" referrerpolicy="no-referrer" />
    <style>
        /* Custom CSS for block gradients and subtle animations */
        :root {
            --color-wear-0: #e0f2fe; /* sky-100 */
            --color-wear-1: #bae6fd; /* sky-200 */
            --color-wear-2: #7dd3fc; /* sky-300 */
            --color-wear-3: #38bdf8; /* sky-400 */
            --color-wear-4: #0ea5e9; /* sky-500 */
            --color-wear-5: #0284c7; /* sky-600 */
            --color-wear-6: #0369a1; /* sky-700 */
            --color-wear-7: #075985; /* sky-800 */
            --color-wear-8: #0c4a6e; /* sky-900 */
            --color-wear-9: #082f49; /* sky-950 */
            --color-op: #d1d5db;     /* gray-300 */
            --color-op-used: #9ca3af; /* gray-400 */
            --color-bad: #ef4444;     /* red-500 */
            --color-writing: #facc15; /* yellow-400 */
        }

        .ssd-block {
            transition: background-color 0.15s ease-in-out, transform 0.1s ease-in-out; /* Faster transition */
            position: relative;
            font-size: 0.5rem;
            line-height: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            color: rgba(0,0,0,0.6);
            overflow: hidden; /* Hide text overflow if block is too small */
        }

        .ssd-block.writing {
            background-color: var(--color-writing) !important;
            transform: scale(1.1);
            z-index: 10;
            color: #374151; /* gray-700 for contrast on yellow */
        }

        .ssd-block.bad {
            background-color: var(--color-bad) !important;
            color: white;
        }

        .ssd-block.op {
            background-color: var(--color-op);
        }
         .ssd-block.op-used {
            background-color: var(--color-op-used);
         }

        /* Wear level colors */
        .wear-0 { background-color: var(--color-wear-0); }
        .wear-1 { background-color: var(--color-wear-1); }
        .wear-2 { background-color: var(--color-wear-2); }
        .wear-3 { background-color: var(--color-wear-3); }
        .wear-4 { background-color: var(--color-wear-4); }
        .wear-5 { background-color: var(--color-wear-5); color: white;}
        .wear-6 { background-color: var(--color-wear-6); color: white;}
        .wear-7 { background-color: var(--color-wear-7); color: white;}
        .wear-8 { background-color: var(--color-wear-8); color: white;}
        .wear-9 { background-color: var(--color-wear-9); color: white;}

        /* Tooltip styling */
        .tooltip {
            position: relative;
            display: inline-block;
        }

        .tooltip .tooltiptext {
            visibility: hidden;
            min-width: 140px; /* Wider tooltip */
            background-color: #374151; /* gray-700 */
            color: #fff;
            text-align: center;
            border-radius: 6px;
            padding: 6px 8px; /* Slightly more padding */
            position: absolute;
            z-index: 50; /* Ensure tooltip is above grid */
            bottom: 115%; /* Position above the element */
            left: 50%;
            margin-left: -70px; /* Adjust margin for new width */
            opacity: 0;
            transition: opacity 0.3s;
            font-size: 0.75rem; /* 12px */
            white-space: nowrap; /* Prevent line breaks */
        }

        .tooltip:hover .tooltiptext {
            visibility: visible;
            opacity: 1;
        }

        /* Slider thumb styling */
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: #0ea5e9; /* sky-500 */
            border-radius: 50%;
            cursor: pointer;
            margin-top: -8px; /* Align thumb vertically */
        }

        input[type=range]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: #0ea5e9; /* sky-500 */
            border-radius: 50%;
            cursor: pointer;
            border: none;
        }
        input[type=range]::-moz-range-track {
             background: #e5e7eb; /* gray-200 */
             height: 4px;
             border-radius: 9999px;
        }
        input[type=range]::-webkit-slider-runnable-track {
             background: #e5e7eb; /* gray-200 */
             height: 4px;
             border-radius: 9999px;
        }

        /* Ensure grid items don't shrink below minimum size */
        .ssd-block {
            min-width: 10px;
            min-height: 10px;
        }
        #ssdGrid {
             min-height: 100px; /* Prevent collapse when block count is very low */
        }

    </style>
</head>
<body class="bg-gray-100 font-sans leading-normal tracking-normal">

    <div class="container mx-auto p-4 md:p-8 max-w-7xl">

        <header class="text-center mb-8">
            <h1 class="text-3xl md:text-4xl font-bold text-sky-800 mb-2">SSD 摩耗平滑化＆冗長性 可視化ツール</h1>
            <p class="text-gray-600">SSDの書き込み分散（ウェアレベリング）と予備領域（オーバープロビジョニング）の動作を高速シミュレーションします。</p>
        </header>

        <div class="grid grid-cols-1 lg:grid-cols-3 gap-8">

            <!-- Controls Section -->
            <div class="lg:col-span-1 bg-white p-6 rounded-lg shadow-lg">
                <h2 class="text-xl font-semibold mb-4 text-sky-700 border-b pb-2">設定</h2>

                <div class="space-y-5">
                    <div>
                        <label for="ssdSize" class="block text-sm font-medium text-gray-700 mb-1">SSD総ブロック数 (<span id="ssdSizeValue">256</span>)</label>
                        <input type="range" id="ssdSize" min="64" max="1024" step="64" value="256" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer range-lg dark:bg-gray-700">
                        <p class="text-xs text-gray-500 mt-1">シミュレーションするブロックの総数。</p>
                    </div>

                    <div>
                        <label for="opPercent" class="block text-sm font-medium text-gray-700 mb-1">オーバープロビジョニング (<span id="opPercentValue">10</span>%)</label>
                        <input type="range" id="opPercent" min="0" max="50" step="1" value="10" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer range-lg dark:bg-gray-700">
                         <p class="text-xs text-gray-500 mt-1">ユーザー領域外の予備ブロックの割合。</p>
                    </div>

                     <div>
                        <label for="maxPE" class="block text-sm font-medium text-gray-700 mb-1">最大 P/E サイクル (<span id="maxPEValue">100</span>)</label>
                        <input type="range" id="maxPE" min="10" max="1000" step="10" value="100" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer range-lg dark:bg-gray-700">
                        <p class="text-xs text-gray-500 mt-1">各ブロックが耐えられる書き込み/消去回数（シミュレーション用）。</p>
                    </div>

                    <div>
                        <label for="writesPerStep" class="block text-sm font-medium text-gray-700 mb-1">書き込みバースト数 (<span id="writesPerStepValue">10</span> writes/step)</label>
                        <input type="range" id="writesPerStep" min="1" max="100" step="1" value="10" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer range-lg dark:bg-gray-700">
                         <p class="text-xs text-gray-500 mt-1">1回のシミュレーションステップで書き込むブロック数。</p>
                    </div>

                    <div>
                        <label for="writeSpeed" class="block text-sm font-medium text-gray-700 mb-1">ステップ間隔 (<span id="writeSpeedValue">100</span> ms/step)</label>
                        <input type="range" id="writeSpeed" min="10" max="500" step="10" value="100" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer range-lg dark:bg-gray-700">
                         <p class="text-xs text-gray-500 mt-1">シミュレーションのステップ間の時間（ミリ秒）。</p>
                    </div>

                    <div>
                        <label for="wearLevelingAlgo" class="block text-sm font-medium text-gray-700 mb-1">ウェアレベリング戦略</label>
                        <select id="wearLevelingAlgo" class="w-full p-2 border border-gray-300 rounded-md focus:ring-sky-500 focus:border-sky-500">
                            <option value="dynamic">動的 (Dynamic) - 最も消耗の少ないブロックを選択</option>
                            <option value="random">ランダム (比較用) - 空きからランダム選択</option>
                            <option value="sequential">シーケンシャル (比較用) - 順次書き込み</option>
                        </select>
                         <p class="text-xs text-gray-500 mt-1">書き込み先ブロックの選択方法。</p>
                    </div>

                    <div class="flex space-x-2 pt-4 border-t mt-4">
                        <button id="startButton" class="flex-1 bg-sky-500 hover:bg-sky-700 text-white font-bold py-2 px-4 rounded inline-flex items-center justify-center transition duration-150 ease-in-out">
                            <i class="fas fa-play mr-2"></i>開始
                        </button>
                        <button id="stopButton" class="flex-1 bg-red-500 hover:bg-red-700 text-white font-bold py-2 px-4 rounded inline-flex items-center justify-center transition duration-150 ease-in-out" disabled>
                            <i class="fas fa-pause mr-2"></i>停止
                        </button>
                        <button id="resetButton" class="flex-1 bg-gray-500 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded inline-flex items-center justify-center transition duration-150 ease-in-out">
                            <i class="fas fa-redo mr-2"></i>リセット
                        </button>
                    </div>
                </div>
            </div>

            <!-- Visualization & Stats Section -->
            <div class="lg:col-span-2">
                 <div class="bg-white p-6 rounded-lg shadow-lg mb-8">
                    <h2 class="text-xl font-semibold mb-4 text-sky-700 border-b pb-2">SSD 状態</h2>
                    <div class="grid grid-cols-2 md:grid-cols-4 gap-4 text-center">
                        <div>
                            <p class="text-sm text-gray-500">総書き込み数</p>
                            <p id="totalWrites" class="text-2xl font-bold text-sky-600">0</p>
                        </div>
                        <div>
                            <p class="text-sm text-gray-500">最大 P/E サイクル</p>
                            <p id="maxPECycles" class="text-2xl font-bold text-sky-600">0</p>
                        </div>
                        <div>
                            <p class="text-sm text-gray-500">不良ブロック数</p>
                            <p id="badBlocks" class="text-2xl font-bold text-red-600">0</p>
                        </div>
                         <div>
                            <p class="text-sm text-gray-500">使用中 OP ブロック</p>
                            <p id="usedOPBlocks" class="text-2xl font-bold text-gray-600">0 / 0</p>
                        </div>
                    </div>
                     <div class="mt-4 pt-4 border-t">
                        <p class="text-sm text-gray-500 mb-1">P/Eサイクル分布 (ユーザーブロック)</p>
                        <div id="peDistributionChart" class="h-16 bg-gray-100 rounded flex items-end">
                           <!-- Distribution chart bars will be added here by JS -->
                        </div>
                         <div class="flex justify-between text-xs text-gray-500 mt-1 px-1">
                            <span>Min</span>
                            <span>Max</span>
                        </div>
                    </div>
                    <div id="statusMessage" class="mt-4 text-center text-yellow-700 font-semibold h-6"></div> {/* Added height to prevent layout shifts */}
                 </div>

                 <div class="bg-white p-6 rounded-lg shadow-lg">
                    <h2 class="text-xl font-semibold mb-4 text-sky-700 border-b pb-2">ブロック可視化</h2>
                    <div id="ssdGrid" class="grid gap-1 justify-center">
                        <!-- SSD blocks will be generated here by JS -->
                    </div>
                    <div class="flex flex-wrap justify-center gap-x-4 gap-y-1 mt-4 text-xs text-gray-600">
                        <div class="flex items-center"><span class="w-3 h-3 rounded-sm bg-sky-100 mr-1 border"></span> 低消耗</div>
                        <div class="flex items-center"><span class="w-3 h-3 rounded-sm bg-sky-900 mr-1 border"></span> 高消耗</div>
                        <div class="flex items-center"><span class="w-3 h-3 rounded-sm bg-gray-300 mr-1 border"></span> OPブロック</div>
                        <div class="flex items-center"><span class="w-3 h-3 rounded-sm bg-gray-400 mr-1 border"></span> 使用中OP</div>
                        <div class="flex items-center"><span class="w-3 h-3 rounded-sm bg-red-500 mr-1 border"></span> 不良ブロック</div>
                         <div class="flex items-center"><span class="w-3 h-3 rounded-sm bg-yellow-400 mr-1 border"></span> 書き込み中</div>
                    </div>
                 </div>
            </div>
        </div>

        <!-- Explanation Section (内容変更なし) -->
        <div class="mt-10 bg-white p-6 rounded-lg shadow-lg">
            <h2 class="text-2xl font-semibold mb-4 text-sky-700">解説</h2>
            <div class="prose max-w-none text-gray-700 space-y-4">
                <section>
                    <h3 class="text-lg font-semibold text-sky-600">摩耗平滑化 (Wear Leveling) とは？</h3>
                    <p>SSDの各記憶素子（NANDフラッシュメモリセル）は、書き込み/消去を行える回数に上限があります（P/Eサイクル寿命）。特定のブロックばかりに書き込みが集中すると、そのブロックだけが早く劣化し、SSD全体の寿命が短くなってしまいます。</p>
                    <p><strong>摩耗平滑化</strong>は、SSDコントローラが書き込み要求を特定の物理ブロックに固定せず、<strong>SSD全体のブロックになるべく均等に書き込みを分散させる技術</strong>です。これにより、特定のブロックだけが極端に消耗することを防ぎ、SSD全体の耐久性を向上させます。</p>
                    <p>このシミュレーションでは、「動的ウェアレベリング」を選択すると、P/Eサイクル数が最も少ないブロックを選んで書き込む様子がわかります。「ランダム」や「シーケンシャル」と比較すると、P/Eサイクルのばらつきが抑えられているのが確認できます。</p>
                </section>
                <section>
                    <h3 class="text-lg font-semibold text-sky-600">冗長性 (Over-Provisioning) とは？</h3>
                    <p><strong>オーバープロビジョニング (OP)</strong> とは、SSDの仕様上の容量よりも多くのNANDフラッシュメモリを物理的に搭載し、その差分をユーザーが直接アクセスできない<strong>予備領域</strong>として確保することです。</p>
                    <p>この予備領域には、主に以下の役割があります：</p>
                    <ul class="list-disc list-inside space-y-1">
                        <li><strong>不良ブロックの代替:</strong> ブロックが寿命（最大P/Eサイクル超過）やエラーで使えなくなった場合に、予備領域のブロックと置き換えます。これにより、ユーザー領域の容量を維持し、ドライブの信頼性を高めます。</li>
                        <li><strong>ウェアレベリングの効率向上:</strong> 空きブロックが多いほど、コントローラはより消耗の少ないブロックを選んで書き込む余裕が生まれます。これにより、ウェアレベリングの効果が高まります。</li>
                        <li><strong>ガベージコレクションの効率向上:</strong> SSDはデータを上書きできず、一度ブロック全体を消去してから書き込む必要があります。ガベージコレクションはこの消去・書き込み処理を行いますが、予備領域があるとデータの一時退避場所として利用でき、処理中の性能低下を抑えられます。</li>
                    </ul>
                    <p>一般的に、OP領域が多いほどSSDの耐久性と持続的な書き込み性能は向上する傾向にあります。このシミュレーションでは、不良ブロックが発生した際にOPブロックが代替として使用される様子（灰色から濃い灰色へ）を見ることができます。</p>
                </section>
                 <section>
                     <h3 class="text-lg font-semibold text-sky-600">シミュレーションの制限</h3>
                     <p>このシミュレーションは概念を理解するための簡略化されたモデルです。実際のSSDコントローラのアルゴリズムはより複雑で、静的ウェアレベリング、ガベージコレクションの詳細、読み取り妨害、エラー訂正コード(ECC)など、多くの要素が絡み合っています。また、実際のP/Eサイクル寿命は通常数千〜数万回ですが、ここでは視覚化のために低い値に設定しています。「書き込みデータ」はツールチップ表示用のダミーであり、実際のデータ管理や消去処理はシミュレートしていません。</p>
                 </section>
            </div>
        </div>

    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // DOM Elements
            const ssdSizeSlider = document.getElementById('ssdSize');
            const opPercentSlider = document.getElementById('opPercent');
            const maxPESlider = document.getElementById('maxPE');
            const writesPerStepSlider = document.getElementById('writesPerStep'); // New slider
            const writeSpeedSlider = document.getElementById('writeSpeed');
            const ssdSizeValueSpan = document.getElementById('ssdSizeValue');
            const opPercentValueSpan = document.getElementById('opPercentValue');
            const maxPEValueSpan = document.getElementById('maxPEValue');
            const writesPerStepValueSpan = document.getElementById('writesPerStepValue'); // New span
            const writeSpeedValueSpan = document.getElementById('writeSpeedValue');
            const startButton = document.getElementById('startButton');
            const stopButton = document.getElementById('stopButton');
            const resetButton = document.getElementById('resetButton');
            const ssdGridDiv = document.getElementById('ssdGrid');
            const totalWritesSpan = document.getElementById('totalWrites');
            const maxPECyclesSpan = document.getElementById('maxPECycles');
            const badBlocksSpan = document.getElementById('badBlocks');
            const usedOPBlocksSpan = document.getElementById('usedOPBlocks');
            const statusMessageDiv = document.getElementById('statusMessage');
            const wearLevelingAlgoSelect = document.getElementById('wearLevelingAlgo');
            const peDistributionChartDiv = document.getElementById('peDistributionChart');

            // Simulation State
            let ssdBlocks = [];
            let totalBlocks = parseInt(ssdSizeSlider.value);
            let opPercent = parseInt(opPercentSlider.value);
            let userBlocksCount = 0;
            let opBlocksCount = 0;
            let availableOPBlocks = [];
            let usedOPBlocksCount = 0;
            let maxPECyclesConfig = parseInt(maxPESlider.value);
            let writesPerStep = parseInt(writesPerStepSlider.value); // New state
            let writeSpeed = parseInt(writeSpeedSlider.value); // Interval time
            let simulationInterval = null;
            let isRunning = false;
            let totalWrites = 0;
            let currentMaxPE = 0;
            let badBlocksCount = 0;
            let sequentialWriteIndex = 0;
            let temporaryStatusMessageTimeout = null; // Timeout ID for status message

            // --- Initialization ---
            function initializeSimulation() {
                stopSimulation();
                ssdBlocks = [];
                availableOPBlocks = [];
                usedOPBlocksCount = 0;
                totalWrites = 0;
                currentMaxPE = 0;
                badBlocksCount = 0;
                sequentialWriteIndex = 0;
                clearTemporaryStatusMessage(); // Clear any pending status message
                statusMessageDiv.textContent = '';


                totalBlocks = parseInt(ssdSizeSlider.value);
                opPercent = parseInt(opPercentSlider.value);
                maxPECyclesConfig = parseInt(maxPESlider.value);
                writesPerStep = parseInt(writesPerStepSlider.value); // Initialize from slider

                opBlocksCount = Math.floor(totalBlocks * (opPercent / 100));
                userBlocksCount = totalBlocks - opBlocksCount;

                for (let i = 0; i < totalBlocks; i++) {
                    const isOP = i >= userBlocksCount;
                    ssdBlocks.push({
                        id: i,
                        element: null,
                        peCycles: 0,
                        isOP: isOP,
                        isBad: false,
                        isOPUsed: false,
                        lastWrittenData: null, // To store dummy data for tooltip
                    });
                    if (isOP) {
                        availableOPBlocks.push(i);
                    }
                }

                renderGrid();
                updateStats();
                updateSliderValues();
                setControlsState(false);
            }

             // --- Grid Rendering ---
            function renderGrid() {
                ssdGridDiv.innerHTML = '';
                const gridCols = Math.ceil(Math.sqrt(totalBlocks));
                 // Adjust block size dynamically, with min/max constraints
                 const availableWidth = ssdGridDiv.offsetWidth || Math.min(window.innerWidth * 0.6, 800); // Estimate container width
                 let blockSize = Math.floor(availableWidth / gridCols) - 2; // Account for gap/border
                 blockSize = Math.max(10, Math.min(blockSize, 40)); // Clamp size between 10px and 40px


                ssdGridDiv.style.gridTemplateColumns = `repeat(${gridCols}, ${blockSize}px)`;
                ssdGridDiv.style.gridAutoRows = `${blockSize}px`; // Make blocks square

                ssdBlocks.forEach(block => {
                    const blockDiv = document.createElement('div');
                    blockDiv.classList.add('ssd-block', 'border', 'border-gray-300', 'rounded-sm');
                    // Removed fixed width/height, using grid auto rows/cols now
                    blockDiv.dataset.id = block.id;

                    const tooltipSpan = document.createElement('span');
                    tooltipSpan.classList.add('tooltiptext');
                    blockDiv.classList.add('tooltip');
                    blockDiv.appendChild(tooltipSpan);

                    block.element = blockDiv;
                    updateBlockVisual(block);
                    ssdGridDiv.appendChild(blockDiv);
                });
            }

            // --- Update Visuals ---
            function updateBlockVisual(block, isWriting = false) {
                if (!block.element) return;

                const element = block.element;
                // Clear previous state classes more reliably
                const classesToRemove = ['writing', 'bad', 'op', 'op-used', ...Array.from({length: 10}, (_, i) => `wear-${i}`)];
                element.classList.remove(...classesToRemove);

                const tooltip = element.querySelector('.tooltiptext');
                 if (tooltip) {
                     const dataStr = block.lastWrittenData ? `, Data: ${block.lastWrittenData}` : '';
                     const stateStr = `${block.isBad ? ' (Bad)' : ''}${block.isOP ? ' [OP]' : ''}${block.isOPUsed ? ' [Used]' : ''}`;
                     tooltip.textContent = `ID: ${block.id}, P/E: ${block.peCycles}${dataStr}${stateStr}`;
                 }
                 // Reset text content, might be set by Bad state later
                 element.textContent = '';

                if (isWriting) {
                    element.classList.add('writing');
                } else if (block.isBad) {
                    element.classList.add('bad');
                    element.textContent = 'X'; // Show 'X' for bad blocks
                } else if (block.isOP) {
                     if (block.isOPUsed) {
                        element.classList.add('op-used');
                     } else {
                        element.classList.add('op');
                     }
                } else {
                    // User block - apply wear level color
                    const wearLevel = Math.min(9, Math.floor((block.peCycles / maxPECyclesConfig) * 10));
                    element.classList.add(`wear-${wearLevel}`);
                    // Optional: Show P/E cycles directly on block if large enough
                    // if (block.peCycles > 0 && element.offsetWidth > 25) {
                    //     element.textContent = block.peCycles;
                    // }
                }
            }

            // --- Update Statistics ---
            function updateStats() {
                totalWritesSpan.textContent = totalWrites.toLocaleString(); // Format large numbers
                maxPECyclesSpan.textContent = currentMaxPE;
                badBlocksSpan.textContent = badBlocksCount;
                usedOPBlocksSpan.textContent = `${usedOPBlocksCount} / ${opBlocksCount}`;
                updatePEDistributionChart();
            }

            function updatePEDistributionChart() {
                peDistributionChartDiv.innerHTML = '';
                const numBins = 10;
                const bins = Array(numBins).fill(0);
                const userBlocks = ssdBlocks.filter(b => !b.isOP && !b.isBad);
                const maxPEInUserBlocks = userBlocks.reduce((max, b) => Math.max(max, b.peCycles), 0);

                if (userBlocks.length === 0 || maxPEInUserBlocks === 0) return; // Nothing to chart

                userBlocks.forEach(block => {
                    const binIndex = Math.min(numBins - 1, Math.floor((block.peCycles / maxPEInUserBlocks) * (numBins -1) )); // Ensure index is within 0-9
                    bins[binIndex]++;
                });

                const maxCountInBin = Math.max(1, ...bins);

                 bins.forEach((count, index) => {
                    const bar = document.createElement('div');
                    const percentageHeight = (count / maxCountInBin) * 100;
                    bar.style.height = `${percentageHeight}%`;
                    bar.style.width = `${100 / numBins}%`;
                    const wearLevel = index; // Match color to bin index directly
                    bar.classList.add(`wear-${wearLevel}`, 'transition-all', 'duration-150', 'ease-in-out');
                    bar.title = `P/E ${Math.round(index * maxPEInUserBlocks / numBins)}-${Math.round((index + 1) * maxPEInUserBlocks / numBins)}: ${count} blocks`;
                    peDistributionChartDiv.appendChild(bar);
                });
            }

             // --- Simulation Logic ---
            function simulationStep() {
                if (!isRunning) return;

                const currentWritesPerStep = parseInt(writesPerStepSlider.value); // Get current value
                const writtenBlockIds = []; // Track IDs written in this step for visual feedback
                let stepWriteCount = 0;
                let exhaustedBlocks = false;

                for (let i = 0; i < currentWritesPerStep; i++) {
                    const targetBlockIndex = findBlockToWrite();

                    if (targetBlockIndex === -1) {
                        setTemporaryStatusMessage('エラー: 書き込み可能なユーザーブロックがありません！', true);
                        exhaustedBlocks = true;
                        stopSimulation();
                        break; // Exit loop
                    }

                    const targetBlock = ssdBlocks[targetBlockIndex];

                    // --- Write Operation ---
                    // Assign dummy data
                    targetBlock.lastWrittenData = Math.random().toString(36).substring(2, 8).toUpperCase();
                    targetBlock.peCycles++;
                    stepWriteCount++;
                    currentMaxPE = Math.max(currentMaxPE, targetBlock.peCycles);
                    writtenBlockIds.push(targetBlock.id);

                    // Check for block failure AFTER incrementing P/E
                    if (targetBlock.peCycles >= maxPECyclesConfig && !targetBlock.isBad) {
                        markBlockAsBad(targetBlock); // Mark state, visual update later
                    }
                } // End of write loop

                totalWrites += stepWriteCount;

                // --- Visual Updates for this Step ---
                // 1. Highlight blocks written in this step
                writtenBlockIds.forEach(id => {
                    const block = ssdBlocks[id];
                    if (block && block.element && !block.isBad) { // Don't highlight already bad blocks as 'writing'
                        updateBlockVisual(block, true); // writing = true
                    } else if (block && block.element && block.isBad) {
                         updateBlockVisual(block); // Ensure bad block visual is up-to-date
                    }
                });

                 // 2. Schedule removal of highlight and final state update
                setTimeout(() => {
                     // Update all blocks that were involved or potentially affected (written, became bad, OP used)
                    const blocksToUpdate = new Set(writtenBlockIds);
                    ssdBlocks.forEach(b => {
                        if (b.isBad || b.isOPUsed) blocksToUpdate.add(b.id);
                    });

                    blocksToUpdate.forEach(id => {
                         const block = ssdBlocks[id];
                         if (block && block.element) {
                            updateBlockVisual(block, false); // writing = false, update to final state
                         }
                    });
                }, 80); // Keep highlight slightly shorter than interval for fast speeds

                updateStats(); // Update overall statistics

                // Schedule next step if still running and blocks not exhausted
                if (isRunning && !exhaustedBlocks) {
                    simulationInterval = setTimeout(simulationStep, writeSpeed);
                } else if (exhaustedBlocks) {
                     setControlsState(false); // Ensure controls are re-enabled if stopped due to exhaustion
                }
            }

            function findBlockToWrite() {
                 const algo = wearLevelingAlgoSelect.value;
                 // Focus on user blocks that are not bad and not currently being replaced by OP
                 const writableUserBlocks = ssdBlocks.filter(b => !b.isOP && !b.isBad);

                 if (writableUserBlocks.length === 0) {
                    // Check if there are any OP blocks that *could* be used but aren't yet
                    // This situation means user space is full of bad blocks, relying only on OP now.
                    // The current logic doesn't explicitly handle writing *to* OP blocks directly,
                    // only using them as replacements. So, if user blocks are full, return -1.
                    return -1;
                 }

                 let targetIndex = -1;

                 if (algo === 'dynamic') {
                    let minPE = Infinity;
                    let candidateIndices = [];
                    writableUserBlocks.forEach(block => {
                        if (block.peCycles < minPE) {
                            minPE = block.peCycles;
                            candidateIndices = [block.id];
                        } else if (block.peCycles === minPE) {
                            candidateIndices.push(block.id);
                        }
                    });
                    targetIndex = candidateIndices[Math.floor(Math.random() * candidateIndices.length)];
                 } else if (algo === 'random') {
                     const randomIndex = Math.floor(Math.random() * writableUserBlocks.length);
                     targetIndex = writableUserBlocks[randomIndex].id;
                 } else if (algo === 'sequential') {
                     let attempts = 0;
                     let found = false;
                     while (attempts < userBlocksCount && !found) { // Limit attempts to user block count
                         const potentialIndex = sequentialWriteIndex % userBlocksCount;
                         const potentialBlock = ssdBlocks[potentialIndex];
                         if (!potentialBlock.isBad && !potentialBlock.isOP) { // Ensure it's a valid user block
                              targetIndex = potentialBlock.id;
                              found = true;
                         }
                         sequentialWriteIndex++; // Increment even if skipped
                         attempts++;
                     }
                     // Fallback if sequential search failed unexpectedly
                     if (!found && writableUserBlocks.length > 0) {
                          targetIndex = writableUserBlocks[0].id;
                     }
                 }

                 return targetIndex;
            }


            function markBlockAsBad(block) {
                if (block.isBad) return; // Already bad

                block.isBad = true;
                badBlocksCount++;
                // Visual update is handled by simulationStep after the loop

                // Handle replacement logic
                if (!block.isOP) {
                    const replacementIndex = findAvailableOPBlock();
                    if (replacementIndex !== -1) {
                        const opBlock = ssdBlocks[replacementIndex];
                        opBlock.isOPUsed = true;
                        usedOPBlocksCount++;
                        availableOPBlocks = availableOPBlocks.filter(idx => idx !== replacementIndex);
                         setTemporaryStatusMessage(`ブロック ${block.id} 不良 -> OP ${replacementIndex} で代替`);
                    } else {
                         setTemporaryStatusMessage(`ブロック ${block.id} 不良。代替OPなし！`, true);
                         // Consider stopping simulation if OP runs out and user blocks fail
                         // stopSimulation();
                    }
                } else {
                     // An OP block itself failed
                     setTemporaryStatusMessage(`OPブロック ${block.id} が不良化`, true);
                     availableOPBlocks = availableOPBlocks.filter(idx => idx !== block.id);
                     if (block.isOPUsed) {
                         usedOPBlocksCount--; // Was used, now bad, so decrement count
                         block.isOPUsed = false; // No longer considered 'used'
                     }
                }
            }

            function findAvailableOPBlock() {
                let bestOPIndex = -1;
                let minPE = Infinity;

                availableOPBlocks.forEach(index => {
                    const opBlock = ssdBlocks[index];
                     // Must be an OP block, not already bad, and not currently used as a replacement
                     if (opBlock.isOP && !opBlock.isBad && !opBlock.isOPUsed) {
                        if (opBlock.peCycles < minPE) {
                            minPE = opBlock.peCycles;
                            bestOPIndex = index;
                        }
                     }
                });
                // Simple strategy: return the first one found with the lowest P/E.
                // Could add randomization if multiple candidates exist.
                return bestOPIndex;
            }

             // --- Status Message Handling ---
            function setTemporaryStatusMessage(message, isWarning = false) {
                 clearTimeout(temporaryStatusMessageTimeout); // Clear previous timeout
                 statusMessageDiv.textContent = message;
                 statusMessageDiv.classList.toggle('text-red-600', isWarning); // Use red for warnings/errors
                 statusMessageDiv.classList.toggle('text-yellow-700', !isWarning);

                 temporaryStatusMessageTimeout = setTimeout(() => {
                     statusMessageDiv.textContent = '';
                     statusMessageDiv.classList.remove('text-red-600');
                 }, 3000); // Clear after 3 seconds
             }

             function clearTemporaryStatusMessage() {
                  clearTimeout(temporaryStatusMessageTimeout);
                  statusMessageDiv.textContent = '';
                  statusMessageDiv.classList.remove('text-red-600', 'text-yellow-700');
             }

            // --- Control Functions ---
            function startSimulation() {
                if (isRunning) return;
                isRunning = true;
                setControlsState(true);
                clearTemporaryStatusMessage(); // Clear any message before starting
                // Use setTimeout for the first step to respect initial delay
                simulationInterval = setTimeout(simulationStep, writeSpeed);
            }

            function stopSimulation() {
                isRunning = false;
                clearTimeout(simulationInterval);
                simulationInterval = null;
                setControlsState(false);
                 // Ensure all blocks are visually updated to their final state (remove writing highlight)
                 ssdBlocks.forEach(block => {
                     if (block.element) updateBlockVisual(block, false);
                 });
            }

             function resetSimulation() {
                stopSimulation();
                initializeSimulation();
            }

            function setControlsState(running) {
                isRunning = running;
                startButton.disabled = running;
                stopButton.disabled = !running;
                resetButton.disabled = running;
                ssdSizeSlider.disabled = running;
                opPercentSlider.disabled = running;
                maxPESlider.disabled = running;
                writesPerStepSlider.disabled = running; // Disable writesPerStep during run
                // writeSpeedSlider can remain enabled
                wearLevelingAlgoSelect.disabled = running;

                // Toggle visual cues for disabled state
                [startButton, stopButton, resetButton, ssdSizeSlider, opPercentSlider, maxPESlider, writesPerStepSlider, wearLevelingAlgoSelect].forEach(el => {
                     el.classList.toggle('opacity-50', el.disabled);
                     el.classList.toggle('cursor-not-allowed', el.disabled);
                });
            }

            function updateSliderValues() {
                 ssdSizeValueSpan.textContent = ssdSizeSlider.value;
                 opPercentValueSpan.textContent = opPercentSlider.value;
                 maxPEValueSpan.textContent = maxPESlider.value;
                 writesPerStepValueSpan.textContent = writesPerStepSlider.value; // Update new slider value
                 writeSpeedValueSpan.textContent = writeSpeedSlider.value;
            }

            // --- Event Listeners ---
            ssdSizeSlider.addEventListener('input', updateSliderValues);
            opPercentSlider.addEventListener('input', updateSliderValues);
            maxPESlider.addEventListener('input', updateSliderValues);
            writesPerStepSlider.addEventListener('input', updateSliderValues); // Listener for new slider
            writeSpeedSlider.addEventListener('input', () => {
                 writeSpeed = parseInt(writeSpeedSlider.value);
                 updateSliderValues();
                 // No need to restart interval immediately, the next step will pick up the new speed
            });

            // Reset simulation if config changes *while not running*
            ssdSizeSlider.addEventListener('change', () => { if (!isRunning) initializeSimulation(); });
            opPercentSlider.addEventListener('change', () => { if (!isRunning) initializeSimulation(); });
            maxPESlider.addEventListener('change', () => { if (!isRunning) initializeSimulation(); });
            writesPerStepSlider.addEventListener('change', () => { if (!isRunning) initializeSimulation(); }); // Reset if changed
            wearLevelingAlgoSelect.addEventListener('change', () => { if (!isRunning) initializeSimulation(); });


            startButton.addEventListener('click', startSimulation);
            stopButton.addEventListener('click', stopSimulation);
            resetButton.addEventListener('click', resetSimulation);

            // Re-render grid on window resize to adjust block sizes (debounced)
            let resizeTimeout;
            window.addEventListener('resize', () => {
                clearTimeout(resizeTimeout);
                resizeTimeout = setTimeout(() => {
                    if (!isRunning) { // Only re-render fully if not running
                        renderGrid();
                    } else {
                         // If running, maybe just adjust grid columns without full re-render?
                         // For simplicity, we'll just let it be slightly off until reset/stop.
                         // Or, force a re-render (might cause visual glitches briefly)
                         // renderGrid(); // This would rebuild DOM, potentially losing state if not careful
                    }
                }, 250); // Debounce resize event
            });


            // --- Initial Call ---
            initializeSimulation();
        });
    </script>

</body>
</html>