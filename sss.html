<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>高機能ストロークエディター</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Font Awesome CDN -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha512-iecdLmaskl7CVkqkXNQ/ZH/XLlvWZOJyj7Yy7tcenmpD1ypASozpmT/E0iPtmFIB46ZmdtAc9eNBvH0H/ZpiBw==" crossorigin="anonymous" referrerpolicy="no-referrer" />
    <style>
        /* Custom CSS for elements difficult to style with Tailwind alone */
        body {
            overscroll-behavior: none; /* Prevent pull-to-refresh */
            font-family: 'Helvetica Neue', Arial, sans-serif; /* Modern font stack */
        }

        #editor-svg {
            touch-action: none; /* Prevent default touch behaviors like scrolling */
            background-color: #f9fafb; /* bg-gray-50 */
            background-image: linear-gradient(rgba(0, 0, 0, 0.05) 1px, transparent 1px),
                              linear-gradient(90deg, rgba(0, 0, 0, 0.05) 1px, transparent 1px);
            background-size: 20px 20px;
            cursor: crosshair;
            border: 1px solid #d1d5db; /* border-gray-300 */
        }

        #editor-svg.editing {
             cursor: default;
        }

        .stroke-path {
            fill: none;
            transition: stroke 0.1s ease-in-out, stroke-width 0.1s ease-in-out;
        }

        .stroke-path:hover {
            filter: brightness(1.2); /* Slightly brighten on hover in edit mode */
        }

        .selected-path {
             /* Use a filter for a more robust highlight effect */
            filter: drop-shadow(0 0 3px rgba(0, 120, 255, 0.8));
        }

        .vertex-handle, .control-point-handle {
            fill: #3b82f6; /* blue-500 */
            stroke: #ffffff;
            stroke-width: 1.5px;
            cursor: move;
            transition: transform 0.1s ease-out, fill 0.1s ease-out;
        }

        .vertex-handle:hover, .control-point-handle:hover {
            transform: scale(1.2);
            fill: #2563eb; /* blue-600 */
        }

        .control-point-line {
            stroke: #9ca3af; /* gray-400 */
            stroke-width: 1px;
            stroke-dasharray: 3, 3;
        }

        /* Style range inputs */
        input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            width: 100%;
            height: 8px;
            background: #d1d5db; /* gray-300 */
            border-radius: 5px;
            outline: none;
            opacity: 0.9;
            transition: opacity .2s;
        }

        input[type="range"]:hover {
            opacity: 1;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            background: #3b82f6; /* blue-500 */
            border-radius: 50%;
            cursor: pointer;
        }

        input[type="range"]::-moz-range-thumb {
            width: 18px;
            height: 18px;
            background: #3b82f6; /* blue-500 */
            border-radius: 50%;
            cursor: pointer;
            border: none; /* Remove default border in Firefox */
        }

        /* Style color input */
        input[type="color"] {
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            width: 40px;
            height: 40px;
            background-color: transparent;
            border: none;
            cursor: pointer;
            padding: 0; /* Remove default padding */
        }
        input[type="color"]::-webkit-color-swatch {
            border-radius: 50%; /* Make it circular */
            border: 2px solid #e5e7eb; /* gray-200 */
             box-shadow: 0 0 0 1px rgba(0, 0, 0, 0.1); /* Subtle inner shadow */
        }
        input[type="color"]::-moz-color-swatch {
            border-radius: 50%; /* Make it circular */
            border: 2px solid #e5e7eb; /* gray-200 */
            box-shadow: 0 0 0 1px rgba(0, 0, 0, 0.1);
        }

        /* Tooltip styling */
        [data-tooltip]:hover::after {
            content: attr(data-tooltip);
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%) translateY(-5px);
            background-color: #1f2937; /* gray-800 */
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.75rem; /* text-xs */
            white-space: nowrap;
            z-index: 10;
        }
        [data-tooltip] {
            position: relative;
        }
    </style>
</head>

<body class="bg-gray-100 flex flex-col h-screen overflow-hidden">

    <!-- Header/Toolbar -->
    <header class="bg-white shadow-md p-2 flex items-center space-x-4 z-10">
        <h1 class="text-xl font-semibold text-gray-700 hidden md:block">ストロークエディター</h1>

        <!-- Mode Switch -->
        <div class="flex bg-gray-200 rounded-lg p-1">
            <button id="draw-mode-btn" class="px-3 py-1 rounded-md text-sm font-medium bg-blue-500 text-white shadow" data-tooltip="描画モード">
                <i class="fas fa-pencil-alt"></i> <span class="hidden sm:inline ml-1">描画</span>
            </button>
            <button id="edit-mode-btn" class="px-3 py-1 rounded-md text-sm font-medium text-gray-600 hover:bg-gray-300" data-tooltip="編集モード">
                <i class="fas fa-mouse-pointer"></i> <span class="hidden sm:inline ml-1">編集</span>
            </button>
        </div>

        <!-- Drawing Tools (Visible in Draw Mode) -->
        <div id="draw-tools" class="flex items-center space-x-3">
            <div data-tooltip="ストローク色" class="flex items-center">
                 <label for="stroke-color" class="sr-only">ストローク色</label>
                 <input type="color" id="stroke-color" value="#000000">
            </div>
            <div data-tooltip="ストローク幅" class="flex items-center space-x-2 w-32">
                 <i class="fas fa-minus text-gray-500"></i>
                <label for="stroke-width" class="sr-only">ストローク幅</label>
                <input type="range" id="stroke-width" min="1" max="50" value="5" class="w-full">
                 <i class="fas fa-plus text-gray-500"></i>
                <span id="stroke-width-value" class="text-xs text-gray-600 w-6 text-right">5</span>
            </div>
             <div data-tooltip="滑らかさ (少ないほど滑らか)" class="flex items-center space-x-2 w-32">
                 <i class="fas fa-wave-square text-gray-500"></i>
                <label for="smoothing" class="sr-only">滑らかさ</label>
                <input type="range" id="smoothing" min="0.5" max="10" step="0.1" value="1.5" class="w-full">
                <span id="smoothing-value" class="text-xs text-gray-600 w-6 text-right">1.5</span>
            </div>
            <div data-tooltip="線の先端形状" class="relative">
                <label for="line-cap" class="sr-only">線の先端</label>
                <select id="line-cap" class="appearance-none bg-gray-100 border border-gray-300 text-gray-700 py-1 pl-2 pr-8 rounded leading-tight focus:outline-none focus:bg-white focus:border-blue-500 text-sm">
                    <option value="round">丸</option>
                    <option value="butt">平</option>
                    <option value="square">四角</option>
                </select>
                <div class="pointer-events-none absolute inset-y-0 right-0 flex items-center px-2 text-gray-700">
                    <i class="fas fa-chevron-down text-xs"></i>
                </div>
            </div>
             <div data-tooltip="線の結合部形状" class="relative">
                <label for="line-join" class="sr-only">線の結合部</label>
                <select id="line-join" class="appearance-none bg-gray-100 border border-gray-300 text-gray-700 py-1 pl-2 pr-8 rounded leading-tight focus:outline-none focus:bg-white focus:border-blue-500 text-sm">
                    <option value="round">丸</option>
                    <option value="miter">尖</option>
                    <option value="bevel">斜角</option>
                </select>
                 <div class="pointer-events-none absolute inset-y-0 right-0 flex items-center px-2 text-gray-700">
                    <i class="fas fa-chevron-down text-xs"></i>
                </div>
            </div>
        </div>

        <!-- Editing Tools (Visible in Edit Mode) -->
         <div id="edit-tools" class="hidden items-center space-x-3">
             <span class="text-sm text-gray-500">パスをクリックして選択</span>
             <button id="delete-path-btn" class="px-3 py-1 rounded-md text-sm font-medium text-red-600 bg-red-100 hover:bg-red-200 disabled:opacity-50 disabled:cursor-not-allowed" disabled data-tooltip="選択したパスを削除">
                <i class="fas fa-trash-alt"></i> <span class="hidden sm:inline ml-1">削除</span>
            </button>
         </div>

         <!-- General Controls -->
         <div class="flex-grow"></div> <!-- Spacer -->
         <div class="flex items-center space-x-3">
            <button id="clear-canvas-btn" class="px-3 py-1 rounded-md text-sm font-medium text-yellow-600 bg-yellow-100 hover:bg-yellow-200" data-tooltip="すべてクリア">
                <i class="fas fa-eraser"></i> <span class="hidden sm:inline ml-1">クリア</span>
            </button>
             <!-- Future: Add Undo/Redo -->
             <!-- <button id="undo-btn" class="px-2 py-1 rounded-md text-sm text-gray-600 bg-gray-200 hover:bg-gray-300 disabled:opacity-50" disabled data-tooltip="元に戻す"><i class="fas fa-undo"></i></button>
             <button id="redo-btn" class="px-2 py-1 rounded-md text-sm text-gray-600 bg-gray-200 hover:bg-gray-300 disabled:opacity-50" disabled data-tooltip="やり直し"><i class="fas fa-redo"></i></button> -->
        </div>
    </header>

    <!-- Main Content Area -->
    <main class="flex-grow relative overflow-hidden">
        <svg id="editor-svg" width="100%" height="100%">
            <!-- Group for paths -->
            <g id="paths-group"></g>
            <!-- Group for handles (on top) -->
            <g id="handles-group"></g>
        </svg>
    </main>

    <!-- Status Bar (Optional) -->
    <!-- <footer class="bg-gray-200 text-xs text-gray-600 p-1 text-center z-10">
        Status: Ready
    </footer> -->

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const svg = document.getElementById('editor-svg');
            const pathsGroup = document.getElementById('paths-group');
            const handlesGroup = document.getElementById('handles-group');
            const strokeColorInput = document.getElementById('stroke-color');
            const strokeWidthInput = document.getElementById('stroke-width');
            const strokeWidthValue = document.getElementById('stroke-width-value');
            const smoothingInput = document.getElementById('smoothing');
            const smoothingValue = document.getElementById('smoothing-value');
            const lineCapSelect = document.getElementById('line-cap');
            const lineJoinSelect = document.getElementById('line-join');
            const clearCanvasBtn = document.getElementById('clear-canvas-btn');
            const drawModeBtn = document.getElementById('draw-mode-btn');
            const editModeBtn = document.getElementById('edit-mode-btn');
            const drawTools = document.getElementById('draw-tools');
            const editTools = document.getElementById('edit-tools');
            const deletePathBtn = document.getElementById('delete-path-btn');

            let isDrawing = false;
            let isEditing = false;
            let isDraggingHandle = false;
            let currentPathElement = null;
            let currentPathData = null; // Stores points and control points for the path being edited
            let points = []; // Raw points collected during draw
            let paths = []; // Array to store { element: SVGElement, data: PathData }
            let selectedPath = null; // { element: SVGElement, data: PathData, index: number }
            let draggedHandle = null; // { type: 'vertex' | 'control', pathIndex: number, vertexIndex: number, controlPointIndex?: number }
            let dragOffset = { x: 0, y: 0 };

            // --- Path Data Structure ---
            // PathData = {
            //   id: string, // Unique ID for the path
            //   points: [{x: number, y: number}], // Simplified points (vertices)
            //   stroke: string,
            //   strokeWidth: number,
            //   lineCap: string,
            //   lineJoin: string,
            //   smoothing: number, // Smoothing factor used
            //   controlPoints1: [{x: number, y: number}], // Control points after vertices
            //   controlPoints2: [{x: number, y: number}]  // Control points before vertices
            // }

            // --- Utility Functions ---
            function getSVGPoint(event) {
                const pt = svg.createSVGPoint();
                if (event.touches && event.touches.length > 0) {
                    pt.x = event.touches[0].clientX;
                    pt.y = event.touches[0].clientY;
                } else {
                    pt.x = event.clientX;
                    pt.y = event.clientY;
                }
                return pt.matrixTransform(svg.getScreenCTM().inverse());
            }

            function distance(p1, p2) {
                return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
            }

            function generateId() {
                return 'path-' + Math.random().toString(36).substr(2, 9);
            }

            // --- Point Simplification (Basic) ---
            // A simple distance-based simplification
            function simplifyPoints(points, tolerance) {
                if (points.length < 3) {
                    return points;
                }
                const simplified = [points[0]];
                let lastPoint = points[0];
                for (let i = 1; i < points.length; i++) {
                    if (distance(points[i], lastPoint) > tolerance) {
                        simplified.push(points[i]);
                        lastPoint = points[i];
                    }
                }
                 // Ensure the last point is always included
                if (lastPoint !== points[points.length - 1]) {
                     simplified.push(points[points.length - 1]);
                }
                return simplified;
            }


            // --- Bezier Curve Generation ---
            // Calculate control points for a smooth curve (Catmull-Rom to Bezier approximation)
            // Returns { cp1: [{x,y}], cp2: [{x,y}] }
            function calculateControlPoints(points, tension = 0.5) {
                const n = points.length;
                if (n < 2) return { cp1: [], cp2: [] };

                const cp1 = [];
                const cp2 = [];

                for (let i = 0; i < n; i++) {
                    const p0 = points[Math.max(0, i - 1)];
                    const p1 = points[i];
                    const p2 = points[Math.min(n - 1, i + 1)];
                    const p3 = points[Math.min(n - 1, i + 2)];

                    // Calculate tangent vectors (scaled)
                    const tangent1 = {
                        x: (p2.x - p0.x) * tension,
                        y: (p2.y - p0.y) * tension
                    };
                    const tangent2 = {
                         x: (p3.x - p1.x) * tension,
                         y: (p3.y - p1.y) * tension
                    };

                    // Control points for the segment from p1 to p2
                    if (i > 0) { // cp2 for the *previous* segment (ending at p1)
                        cp2[i - 1] = {
                            x: p1.x - tangent1.x,
                            y: p1.y - tangent1.y
                        };
                    }
                     if (i < n - 1) { // cp1 for the *current* segment (starting at p1)
                        cp1[i] = {
                            x: p1.x + tangent1.x,
                            y: p1.y + tangent1.y
                        };
                     }
                }

                 // Handle start and end explicitly (mirror control points)
                if (n > 1) {
                     // If only 2 points, use linear interpolation approximation (or just straight line)
                     if (n === 2) {
                         const midX = (points[0].x + points[1].x) / 2;
                         const midY = (points[0].y + points[1].y) / 2;
                         cp1[0] = { x: (midX + points[0].x) / 2, y: (midY + points[0].y) / 2 };
                         cp2[0] = { x: (midX + points[1].x) / 2, y: (midY + points[1].y) / 2 };
                     } else {
                         // Start point's control point (cp1[0]) already calculated using p0=p0, p1=p0, p2=p1, p3=p2
                         // End point's control point (cp2[n-2]) needs careful check (using p0=n-3, p1=n-2, p2=n-1, p3=n-1)
                         const p_n_3 = points[n - 3];
                         const p_n_2 = points[n - 2];
                         const p_n_1 = points[n - 1];
                         const tangent_end = {
                              x: (p_n_1.x - p_n_3.x) * tension,
                              y: (p_n_1.y - p_n_3.y) * tension
                         }
                         cp2[n - 2] = { // Control point before the last vertex
                             x: p_n_1.x - tangent_end.x,
                             y: p_n_1.y - tangent_end.y
                         };
                    }
                 }

                 // Ensure arrays have the correct length (n-1)
                 while (cp1.length < n - 1) cp1.push(null);
                 while (cp2.length < n - 1) cp2.push(null);


                return { cp1: cp1.slice(0, n - 1), cp2: cp2.slice(0, n - 1) };
            }


            // --- SVG Path String Generation ---
            function createPathString(pathData) {
                const { points, controlPoints1, controlPoints2 } = pathData;
                if (!points || points.length === 0) return "";
                if (points.length === 1) return `M ${points[0].x} ${points[0].y}`; // Draw a dot

                let d = `M ${points[0].x} ${points[0].y}`;
                if (points.length === 2 || !controlPoints1 || !controlPoints2) {
                    // Draw straight line if only two points or no control points
                     if (points.length > 1) {
                        d += ` L ${points[1].x} ${points[1].y}`;
                     }
                } else {
                    for (let i = 0; i < points.length - 1; i++) {
                        const cp1 = controlPoints1[i];
                        const cp2 = controlPoints2[i];
                        const p2 = points[i + 1];
                        if (cp1 && cp2 && p2) {
                             d += ` C ${cp1.x} ${cp1.y}, ${cp2.x} ${cp2.y}, ${p2.x} ${p2.y}`;
                        } else if (p2) {
                             // Fallback to line if control points are missing for some reason
                             console.warn("Missing control points for segment", i, "Falling back to L");
                             d += ` L ${p2.x} ${p2.y}`;
                        }

                    }
                }
                return d;
            }

            // --- Drawing Logic ---
            function startDrawing(event) {
                if (isEditing) return;
                event.preventDefault(); // Prevent text selection/dragging images
                isDrawing = true;
                points = [getSVGPoint(event)];

                currentPathElement = document.createElementNS("http://www.w3.org/2000/svg", "path");
                currentPathElement.setAttribute('class', 'stroke-path');
                currentPathElement.setAttribute('stroke', strokeColorInput.value);
                currentPathElement.setAttribute('stroke-width', strokeWidthInput.value);
                currentPathElement.setAttribute('stroke-linecap', lineCapSelect.value);
                currentPathElement.setAttribute('stroke-linejoin', lineJoinSelect.value);
                currentPathElement.setAttribute('d', `M ${points[0].x} ${points[0].y}`); // Start path
                currentPathElement.dataset.id = generateId(); // Assign unique ID

                pathsGroup.appendChild(currentPathElement);
            }

            function draw(event) {
                if (!isDrawing || isEditing) return;
                event.preventDefault();
                const point = getSVGPoint(event);
                points.push(point);

                // Optional: Live preview with straight lines (can be laggy)
                // let d = `M ${points[0].x} ${points[0].y}`;
                // for (let i = 1; i < points.length; i++) {
                //     d += ` L ${points[i].x} ${points[i].y}`;
                // }
                // currentPathElement.setAttribute('d', d);

                 // More performant: Throttle the preview update if desired
            }

            function stopDrawing(event) {
                if (!isDrawing || isEditing) return;
                event.preventDefault();
                isDrawing = false;

                 if (points.length < 2) {
                     // If not enough points, remove the preliminary path/dot
                     if(currentPathElement) currentPathElement.remove();
                     currentPathElement = null;
                     points = [];
                     return;
                 }

                // 1. Simplify points
                const smoothingFactor = parseFloat(smoothingInput.value) || 1.5;
                const simplified = simplifyPoints(points, smoothingFactor);

                 // If simplification results in too few points, keep original or handle appropriately
                 if (simplified.length < 2) {
                     if (points.length >= 2) {
                         // Use original start/end if simplification failed badly
                         const finalPoints = [points[0], points[points.length-1]];
                         const controls = calculateControlPoints(finalPoints);
                         const pathData = {
                             id: currentPathElement.dataset.id,
                             points: finalPoints,
                             controlPoints1: controls.cp1,
                             controlPoints2: controls.cp2,
                             stroke: strokeColorInput.value,
                             strokeWidth: strokeWidthInput.value,
                             lineCap: lineCapSelect.value,
                             lineJoin: lineJoinSelect.value,
                             smoothing: smoothingFactor
                         };
                         const d = createPathString(pathData);
                         currentPathElement.setAttribute('d', d);
                         paths.push({ element: currentPathElement, data: pathData });
                     } else {
                         // Single click, treat as a dot maybe? Or just remove.
                         currentPathElement.remove();
                     }
                 } else {
                     // 2. Calculate control points
                     const controls = calculateControlPoints(simplified);

                     // 3. Create final path data object
                      const pathData = {
                          id: currentPathElement.dataset.id,
                          points: simplified,
                          controlPoints1: controls.cp1,
                          controlPoints2: controls.cp2,
                          stroke: strokeColorInput.value,
                          strokeWidth: strokeWidthInput.value,
                          lineCap: lineCapSelect.value,
                          lineJoin: lineJoinSelect.value,
                          smoothing: smoothingFactor
                      };

                     // 4. Generate SVG path string
                     const d = createPathString(pathData);
                     currentPathElement.setAttribute('d', d);

                     // 5. Store the path and its data
                     paths.push({ element: currentPathElement, data: pathData });
                     addPathEventListeners(currentPathElement); // Add listener for editing clicks
                 }


                // Reset for next path
                currentPathElement = null;
                points = [];
            }

             // --- Editing Logic ---
            function toggleMode(targetMode) {
                 isDrawing = false; // Stop any drawing
                 if (selectedPath) deselectPath(); // Deselect on mode change

                 if (targetMode === 'edit') {
                     isEditing = true;
                     svg.classList.add('editing');
                     drawModeBtn.classList.remove('bg-blue-500', 'text-white', 'shadow');
                     drawModeBtn.classList.add('text-gray-600', 'hover:bg-gray-300');
                     editModeBtn.classList.add('bg-blue-500', 'text-white', 'shadow');
                     editModeBtn.classList.remove('text-gray-600', 'hover:bg-gray-300');
                     drawTools.classList.add('hidden');
                     editTools.classList.remove('hidden');
                     paths.forEach(p => p.element.style.pointerEvents = 'stroke'); // Make paths clickable
                 } else { // Draw mode
                     isEditing = false;
                     isDraggingHandle = false;
                     draggedHandle = null;
                     svg.classList.remove('editing');
                     editModeBtn.classList.remove('bg-blue-500', 'text-white', 'shadow');
                     editModeBtn.classList.add('text-gray-600', 'hover:bg-gray-300');
                     drawModeBtn.classList.add('bg-blue-500', 'text-white', 'shadow');
                     drawModeBtn.classList.remove('text-gray-600', 'hover:bg-gray-300');
                     editTools.classList.add('hidden');
                     drawTools.classList.remove('hidden');
                     paths.forEach(p => p.element.style.pointerEvents = 'none'); // Make paths not clickable
                     clearHandles();
                 }
            }

            function selectPath(pathElement) {
                if (selectedPath && selectedPath.element === pathElement) return; // Already selected

                deselectPath(); // Deselect previous one

                const pathIndex = paths.findIndex(p => p.element === pathElement);
                if (pathIndex === -1) return;

                selectedPath = { ...paths[pathIndex], index: pathIndex };
                selectedPath.element.classList.add('selected-path');
                deletePathBtn.disabled = false;
                drawHandles(selectedPath.data);
            }

            function deselectPath() {
                if (selectedPath) {
                    selectedPath.element.classList.remove('selected-path');
                }
                selectedPath = null;
                deletePathBtn.disabled = true;
                clearHandles();
            }

             function drawHandles(pathData) {
                 clearHandles();
                 const { points, controlPoints1, controlPoints2 } = pathData;

                 if (!points) return;

                 // Draw vertex handles
                 points.forEach((p, index) => {
                     const handle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
                     handle.setAttribute('cx', p.x);
                     handle.setAttribute('cy', p.y);
                     handle.setAttribute('r', 5); // Adjust size as needed
                     handle.setAttribute('class', 'vertex-handle');
                     handle.dataset.type = 'vertex';
                     handle.dataset.pathId = pathData.id;
                     handle.dataset.index = index;
                     addHandleEventListeners(handle);
                     handlesGroup.appendChild(handle);

                     // Draw control point handles and lines (if applicable)
                     if (controlPoints1 && controlPoints2) {
                         const cp1 = controlPoints1[index]; // Control point *after* this vertex
                         const cp2 = controlPoints2[index - 1]; // Control point *before* this vertex (from prev segment)

                         if (cp1 && index < points.length -1) { // Draw CP1 and line to it
                             const cp1Handle = createControlPointHandle(cp1.x, cp1.y, pathData.id, index, 1);
                             handlesGroup.appendChild(cp1Handle);
                             const line1 = createControlPointLine(p.x, p.y, cp1.x, cp1.y);
                             handlesGroup.appendChild(line1);
                         }
                         if (cp2 && index > 0) { // Draw CP2 and line to it
                             const cp2Handle = createControlPointHandle(cp2.x, cp2.y, pathData.id, index -1, 2); // Belongs to segment index-1
                             handlesGroup.appendChild(cp2Handle);
                             const line2 = createControlPointLine(p.x, p.y, cp2.x, cp2.y);
                             handlesGroup.appendChild(line2);
                         }
                     }
                 });
             }

             function createControlPointHandle(cx, cy, pathId, vertexIndex, cpIndex) { // cpIndex 1 for cp1, 2 for cp2
                 const handle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
                 handle.setAttribute('cx', cx);
                 handle.setAttribute('cy', cy);
                 handle.setAttribute('r', 4); // Smaller than vertex handles
                 handle.setAttribute('class', 'control-point-handle');
                 handle.setAttribute('fill', '#f59e0b'); // amber-500
                 handle.dataset.type = 'control';
                 handle.dataset.pathId = pathId;
                 handle.dataset.vertexIndex = vertexIndex; // Vertex the control point *follows* (for cp1) or *precedes* (for cp2)
                 handle.dataset.cpIndex = cpIndex;
                 addHandleEventListeners(handle);
                 return handle;
             }

            function createControlPointLine(x1, y1, x2, y2) {
                 const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
                 line.setAttribute('x1', x1);
                 line.setAttribute('y1', y1);
                 line.setAttribute('x2', x2);
                 line.setAttribute('y2', y2);
                 line.setAttribute('class', 'control-point-line');
                 return line;
             }

             function clearHandles() {
                 while (handlesGroup.firstChild) {
                     handlesGroup.removeChild(handlesGroup.firstChild);
                 }
             }

             function startHandleDrag(event, handle) {
                 event.stopPropagation(); // Prevent SVG click/drag handlers
                 if (!isEditing || !selectedPath) return;

                 isDraggingHandle = true;
                 const handleType = handle.dataset.type;
                 const vertexIndex = parseInt(handle.dataset.index || handle.dataset.vertexIndex, 10); // index for vertex, vertexIndex for CP
                 const cpIndex = handle.dataset.cpIndex ? parseInt(handle.dataset.cpIndex, 10) : null; // 1 or 2 if CP
                 const pathId = handle.dataset.pathId;

                 // Find the correct path (should match selectedPath but double-check)
                 if (selectedPath.data.id !== pathId) {
                      console.error("Handle path ID mismatch!");
                      isDraggingHandle = false;
                      return;
                 }

                 draggedHandle = {
                     element: handle,
                     type: handleType,
                     pathIndex: selectedPath.index,
                     vertexIndex: vertexIndex,
                     cpIndex: cpIndex
                 };

                 const currentPos = getSVGPoint(event);
                 const handleX = parseFloat(handle.getAttribute('cx'));
                 const handleY = parseFloat(handle.getAttribute('cy'));
                 dragOffset = { x: currentPos.x - handleX, y: currentPos.y - handleY };

                 svg.style.cursor = 'move';
             }

             function dragHandle(event) {
                 if (!isDraggingHandle || !draggedHandle || !selectedPath) return;
                 event.preventDefault();

                 const pos = getSVGPoint(event);
                 const newX = pos.x - dragOffset.x;
                 const newY = pos.y - dragOffset.y;

                 // Update handle position visually
                 draggedHandle.element.setAttribute('cx', newX);
                 draggedHandle.element.setAttribute('cy', newY);

                 // Update path data
                 const pathData = selectedPath.data;
                 const vIndex = draggedHandle.vertexIndex;

                 if (draggedHandle.type === 'vertex') {
                     pathData.points[vIndex] = { x: newX, y: newY };

                     // IMPORTANT: When moving a vertex, we need to recalculate the control points
                     // around it to maintain smoothness. This is complex.
                     // For simplicity here, we recalculate *all* control points for the path.
                     // A more optimized approach would only recalculate affected control points.
                     const newControls = calculateControlPoints(pathData.points);
                     pathData.controlPoints1 = newControls.cp1;
                     pathData.controlPoints2 = newControls.cp2;

                 } else if (draggedHandle.type === 'control') {
                     const cpIndex = draggedHandle.cpIndex; // 1 or 2
                     const segmentIndex = cpIndex === 1 ? vIndex : vIndex; // cp1 belongs to segment vIndex, cp2 belongs to segment vIndex

                     if (cpIndex === 1 && segmentIndex < pathData.controlPoints1.length) {
                         pathData.controlPoints1[segmentIndex] = { x: newX, y: newY };
                         // Optional: Maintain C1 continuity (mirror the opposite control point)
                         // This requires more complex logic relating cp1[i] and cp2[i] or cp1[i] and cp2[i-1]
                     } else if (cpIndex === 2 && segmentIndex < pathData.controlPoints2.length) {
                          pathData.controlPoints2[segmentIndex] = { x: newX, y: newY };
                          // Optional: Maintain C1 continuity
                     }
                 }

                 // Regenerate the path string
                 const d = createPathString(pathData);
                 selectedPath.element.setAttribute('d', d);

                 // Redraw all handles to reflect updated control point positions etc.
                 // This is inefficient but simpler than updating individual handle lines.
                 drawHandles(pathData);
                 // Re-find the dragged handle element after redraw (since elements were replaced)
                 const newHandleElement = handlesGroup.querySelector(`[data-type="${draggedHandle.type}"][data-path-id="${pathData.id}"][data-vertex-index="${draggedHandle.vertexIndex}"]` + (draggedHandle.cpIndex ? `[data-cp-index="${draggedHandle.cpIndex}"]` : '[data-index]'));
                 if (newHandleElement) draggedHandle.element = newHandleElement;

             }

             function stopHandleDrag(event) {
                 if (!isDraggingHandle) return;
                 isDraggingHandle = false;
                 draggedHandle = null;
                 svg.style.cursor = 'default'; // Reset cursor back
                 // No need to redraw path again, it was updated during drag
             }

             function deleteSelectedPath() {
                 if (!selectedPath) return;

                 const index = selectedPath.index;
                 paths[index].element.remove(); // Remove SVG element
                 paths.splice(index, 1); // Remove from data array

                 // Adjust indices for subsequent paths if needed (though currently not critical as we find by element/ID)

                 deselectPath(); // Deselect and clear handles
                 // Update indices for remaining path event listeners if necessary (safer to re-add)
                 reassignPathListeners();
             }

            function clearCanvas() {
                pathsGroup.innerHTML = ''; // Clear SVG paths
                clearHandles(); // Clear any visible handles
                paths = []; // Clear data array
                selectedPath = null;
                isDrawing = false;
                isDraggingHandle = false;
                draggedHandle = null;
                deletePathBtn.disabled = true; // Disable delete button
            }

             // --- Event Listeners ---
             function addPathEventListeners(pathElement) {
                 pathElement.addEventListener('click', (e) => {
                     if (isEditing && !isDraggingHandle) {
                         e.stopPropagation(); // Prevent SVG click causing deselect
                         selectPath(pathElement);
                     }
                 });
             }

             function addHandleEventListeners(handleElement) {
                 handleElement.addEventListener('mousedown', (e) => startHandleDrag(e, handleElement));
                 handleElement.addEventListener('touchstart', (e) => startHandleDrag(e, handleElement)); // Add touch support
             }

             function reassignPathListeners() {
                 // Remove old listeners first? Might not be strictly necessary if using element references
                 paths.forEach(p => {
                     // Clone and replace to potentially remove old listeners if needed (simple approach)
                     // const newElement = p.element.cloneNode(true);
                     // p.element.parentNode.replaceChild(newElement, p.element);
                     // p.element = newElement;
                     addPathEventListeners(p.element);
                 });
             }


            svg.addEventListener('mousedown', startDrawing);
            svg.addEventListener('mousemove', draw);
            svg.addEventListener('mouseup', stopDrawing);
            svg.addEventListener('mouseleave', stopDrawing); // Stop if mouse leaves SVG

            svg.addEventListener('touchstart', startDrawing, { passive: false }); // Use passive: false to allow preventDefault
            svg.addEventListener('touchmove', draw, { passive: false });
            svg.addEventListener('touchend', stopDrawing);
            svg.addEventListener('touchcancel', stopDrawing);

             // Global listeners for handle dragging (on document or window to catch mouseup outside SVG)
             document.addEventListener('mousemove', dragHandle);
             document.addEventListener('mouseup', stopHandleDrag);
             document.addEventListener('touchend', stopHandleDrag);
             document.addEventListener('touchcancel', stopHandleDrag);


            strokeWidthInput.addEventListener('input', (e) => {
                strokeWidthValue.textContent = e.target.value;
                 if (isEditing && selectedPath) {
                      selectedPath.element.setAttribute('stroke-width', e.target.value);
                      selectedPath.data.strokeWidth = e.target.value;
                      // No need to redraw path, just update attribute
                 }
            });
            smoothingInput.addEventListener('input', (e) => {
                smoothingValue.textContent = parseFloat(e.target.value).toFixed(1);
                // Note: Smoothing only affects *new* paths currently.
                 // Applying smoothing change to existing paths would require re-simplifying and recalculating.
            });
             strokeColorInput.addEventListener('input', (e) => {
                  if (isEditing && selectedPath) {
                      selectedPath.element.setAttribute('stroke', e.target.value);
                      selectedPath.data.stroke = e.target.value;
                  }
             });
             lineCapSelect.addEventListener('change', (e) => {
                 if (isEditing && selectedPath) {
                      selectedPath.element.setAttribute('stroke-linecap', e.target.value);
                      selectedPath.data.lineCap = e.target.value;
                  }
             });
              lineJoinSelect.addEventListener('change', (e) => {
                  if (isEditing && selectedPath) {
                      selectedPath.element.setAttribute('stroke-linejoin', e.target.value);
                      selectedPath.data.lineJoin = e.target.value;
                  }
             });

            clearCanvasBtn.addEventListener('click', clearCanvas);

            drawModeBtn.addEventListener('click', () => toggleMode('draw'));
            editModeBtn.addEventListener('click', () => toggleMode('edit'));
            deletePathBtn.addEventListener('click', deleteSelectedPath);

             // Deselect path when clicking on empty SVG area in edit mode
             svg.addEventListener('click', (e) => {
                 if (isEditing && e.target === svg) { // Ensure click is directly on SVG, not a path/handle
                      deselectPath();
                 }
             });

             // Initial setup
            toggleMode('draw'); // Start in draw mode
            strokeWidthValue.textContent = strokeWidthInput.value;
            smoothingValue.textContent = parseFloat(smoothingInput.value).toFixed(1);

        });
    </script>

</body>

</html>